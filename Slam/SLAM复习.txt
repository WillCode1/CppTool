王斌 15355414310
will1234 dw940613
====================
dot -T pdf gtsam_opt.dot -o graph.pdf

slam技术栈
1.标定: 
2.前端里程计
--->icp,ndt,pl-icp,nicp,gicp
--->特征点匹配,pnp(vslam)
--->运动畸变矫正,imu预积分
--->非线性优化: 高斯牛顿法，LM
3.后端优化
--->滤波: ekf，pf
--->g2o, Ceres: BA, 图优化
--->控制BA规模: 位姿图, 共视图Covisibility graph, 滑动窗口法
--->gtsam: 因子图
--->LOAM: map2map, 多次扫描的点云与现有地图进行匹配，消除LO增量中的误差
4.回环检测
--->branch and bound + icp
--->DBoW2/DBoW3
--->里程计推算位置(LEGO-LOAM) + icp
--->SC-LEGO-LOAM：Scan Context
--->深度学习
====================
ekf：
--->xt = A*xt-1 + B*ut + εt
--->zt = C*xt + δ
--->1.控制更新 2.计算K卡尔曼增益 3.测量更新

icp：https://blog.csdn.net/electech6/article/details/95235145
迭代过程
实际上刚才我们只完成了一次计算，而ICP的全称是Iterative Closest Point，即迭代最近点。我们来理解一下整个过程
1.对P中的每个点，在Q中找到匹配的最近点。这里需要注意，并不是每次的点云都是一一匹配，点云的数量是一方面，另外可以预见的是，很容易出现多对一最近点匹配，当然，可以通过一些额外的限定在达到一对一匹配的效果。
2.根据上述过程计算最优的R和T.
3.利用得到的位姿作用于P，如果此时的误差大于阈值，则重新进行迭代，直到迭代次数达到阈值或者误差小于阈值。
简单的理解，有点像梯度下降寻找极值点的过程，同样的，一个好的初值对加快ICP的收敛过程也十分重要。
另外点对点的计算量十分大，复杂度为$O(mn)$，在一维的情况下，二分查找是常见的优化，对高维的情况，一个类似的过程是通过KD树来实现的。
KD树构建的复杂度为O(log(m))，查找的复杂度为O(mlog(n))，所以利用KD查找最近邻的复杂度为O(mlog(n))，远小于O(mn)。

优化的配准方法
1.基于特征点的配准方法：减少数据量、噪声
2.pl-icp：二阶收敛精度高，先找到最近两点并连线，最小化点到线之间误差
https://blog.csdn.net/Evanismlii/article/details/111868631
3.gicp：https://blog.csdn.net/pingjun5579/article/details/119029370

ndt：https://zhuanlan.zhihu.com/p/96908474
1）划分网格
2）计算各网格的PDF
3）对每个点云数据，找到对应的网格点，并根据PDF和评分函数计算结果
4）根据结果更新g和H，计算新的步长
5）判断是否收敛或达到迭代次数，是则跳出，否则继续步骤3-5

amcl：https://blog.csdn.net/weixin_38145317/article/details/82852580
PnP：https://www.cnblogs.com/yepeichu/p/12670818.html
P3P/EPnP：
--->利用三角形相似性质，求解2组3个投影点在相机坐标系下的3D坐标
--->最后把问题转换成求解两组三维匹配点的位姿估计问题（ICP）
--->ICP又分利用SVD分解和Bundle Adjustment两种方式，但是本质上并无区别，毕竟SVD也是构建非线性最小二乘问题
BA：非线性优化
Cartographer：https://blog.csdn.net/weixin_36976685/article/details/84994701?spm=1001.2014.3001.5502
cartographer前端两种匹配：https://blog.csdn.net/xiaoma_bk/article/details/85046905
branch and bound：
orb-slam2：https://www.cnblogs.com/yepeichu/p/11602502.html
rf2o：前提静态场景 https://zhuanlan.zhihu.com/p/51010526
LIO-SAM：
laser畸变校正：一帧激光中，首尾点云位姿差值，通过角度比例插值修正

非线性优化方法：https://zhuanlan.zhihu.com/p/101292765?utm_source=wechat_session
--->一阶
--->二阶牛顿法
--->高斯牛顿法：比牛顿法快，矩阵H不满秩则无法迭代、不准确、不收敛(J(x)J^T(x)△x = -J(x)f(x) / H△x = g)
--->LM：增加信赖域，解决H矩阵不满秩或非正定的情况（相当于条件选择一阶或二阶法(H+λI)△x = g)

点云处理：
(1)点云滤波，去除NaN值得无效点云
--->pcl::removeNaNFromPointCloud

(2)点云下采样: pcl::VoxelGrid<PointType> downSizeFilter;
--->downSizeFilter.setInputCloud(surfPointsLessFlatScan);
--->downSizeFilter.setLeafSize(0.2, 0.2, 0.2);
--->downSizeFilter.filter(surfPointsLessFlatScanDS);

(3)kd-tree：表示k维空间中点集合
--->pcl::KdTreeFLANN<pcl::PointXYZ> kdtree;
--->kdtree.nearestKSearch();
--->kdtree.radiusSearch();

=========================================
VIO相对于VO的好处：
1.恢复尺度：IMU能够提供尺度信息(加速度计)，解决单目VO的无法恢复尺度的问题。
2.应对纯旋转：在纯旋转的情况下，VO位姿解算会出现奇异，VIO可以利用IMU的陀螺仪(角速度计)来估计纯旋转运动。
3.应对短时间图像特征缺失：在出现图像过曝、图像过暗、环境纹理不足时，VO会无法工作，而VIO能在VO失效的情况下利用IMU积分来进行运动估计，能够应对短时间的视觉特征缺失（IMU积分越久累积误差会越大），比VO具有更高的鲁棒性。
4.精度更高：VIO融合了两种传感器的信息，位姿估计的精度要更高。

=========================================
5.LMOptimization：https://blog.csdn.net/weixin_37835423/article/details/111587379
6.branch and bound: fast_correlative_scan_matcher_2d.cc
7.LEGO-LOAM、FAST-LIO
8.my localization
9.my slam
10.数学进阶

